# 리스트
  - 배열로 구현
  - Linked List로 구현
  
# Linked List
- 어떤 데이터를 저장할때 다음 순서의 자료가 있는 위치를 데이터에 포함시키는 방식으로 자료를 저장  
- 데이터의 추가/삭제는 해당 데이터를 검색하는데까지 시간이 걸리기 때문에 O(n)
- 배열과는 달리 새로운 자료를 추가하거나 삭제하는것이 용이하다(배열은 자료를 빈틈없이 유지하기위해 데이터를 추가하거나 삭제할때마다 자료를 땡기거나 밀어야 한다 O(N) )
- 배열과는 달리 특정 노드를 불러내기 어렵다(배열은 인덱스로 자료에 접근할수있어 특정자료를 불러내기 편리한반면, 연결리스트는 자료 번호가없이 그저 연결관계만 있기 때문에)
- 배열에비해 데이터의 추가/삽입/삭제 가 용이하나, 순차적으로 탐색하지 않으면 특정위치의 요소에 접근할수없어 일반적으로 탐색속도가 떨어진다. 즉 탐색 또는 정렬을 자주하면 배열을, 추가/삭제가 많으면 연결리스트를 사용하는것이 유리함.
- 메모리면에서 효율적이다.(배열은 연속된 메모리공간을 할당받아야하고 사용하지않는 공간까지 모두 예약해둬야하지만, 링크드리스트는 사용하는 공간만 가지고있으므로)


<details>
  <summary>Stack</summary>
  
  ## Stack
  **Last In First Out의 자료구조. 데이터를 위로쌓듯이올리고, 뺄때 위에서 뺀다.**
  
  - 배열이든, 연결리스트든 간단하게 구현 가능
  - 운영체제에서는.... 프로세스를 구성하는 4개 요소중 한 부분.
    - 어떤함수든 호출되는 순간 그 함수를 위한 stack frame이 할당됨.
    - 해당 함수가 종료될때, stack frame을 다 걷어내고 그 아래에 return값을 반환해서 자신을 호출한 함수에게 return값 전달
    - 그래프 탐색알고리즘인 DFS 구현시, 잘 사용되는 자료구조.
</details>
  
  
<details>
  <summary>Queue</summary>
  
  ## Queue
  ** First Input First Out의 자료구조 **
  
  - Enque, Deque 연산으로 데이터를 넣거나 뺀다.
  - 배열로구현시 Deque하게되면 앞에가 비어서 땡겨주는 연산을 하느라 O(N)이 될수있는데, 이때문에 배열로 구현할땐 원형 큐로 구현 한다.
  - Linked List로 구현하면 간단하게 구현 가능
  
## Priority Queue
**Queue의 일종인데, Deque시 순서상관없이 가장 높은 우선순위를 가진 노드가 빠져나오는게 다르다. **
  - 배열 혹은 링크드리스트로 구현
    - 
  - 힙트리 자료구조로 구현
    
</details>
  
<details>
  <summary>Tree</summary>
  
  ## Tree  
  **싸이클이 없는 그래프. 루트노드가 정의되어 있음.**
- 이진트리(Binary Tree)
  - 이진트리 종류
    - full binary tree: 모든 노드의 자식은 0개나 2개
    - perfect binary tree: 모든 리프노드의 높이가 같다.
    - complete binary tree: 위에서 아래로, 왼쪽에서 오른쪽으로 빠짐없이 채워져있는 트리.
  - 이진트리 순회방법
    - in-order  : 왼,나,오 (스택 or 재귀로 구현)
    - pre-order : 나,왼,오 (스택 or 재귀로 구현)
    - post-order: 왼,오,나 (스택 or 재귀로 구현)
    - level-order: BFS처럼, 레벨순서로 방문함(큐로 구현)
  - 이진 탐색 트리(Binary Search Tree, BST)
    - 이진트리의 일종으로, 특정 규칙에 따라 노드의 위치가 결정되는데, 그 규칙은 "왼쪽자식노드<=부모노드<=오른쪽자식노드" 임
    - 탐색/삽입/삭제 모두 O(log N)
    - AVL트리등을 사용하여 tree가 skew되는상황을 막지않으면, 탐색에 O(N)이 소요될 수도 있다.
  - AVL-tree
    - 가장 처음 나온 자가 균형 이진 탐색 트리.
    - 모든 노드에서 오른쪽 트리와 왼쪽 트리의 height차이가 1 이하로만 나게 함.
    - 삽입/삭제를 할 때마다 균형이 안맞는것을 맞추기위해 트리의 일부를 왼쪽 혹은 오른쪽으로 회전시켜야 함
    - 균형은 아래의 Red-black tree보다 훨씬 잘 잡히지만, 그렇기 때문에 Red-black tree보다 삽입과 제거가 느리고 탐색자체는 빠르다. 그래서 보통 자가 균형 이진 탐색 트리가 필요한경우, Red-black tree 사용한다.
  - Red-black tree
    - 이상적이나 최악의 상황에서 탐색/삽입/삭제 모두 시간복잡도 O(N)이다. ~~궁극의 트리~~
    - 
    
  - 힙(Heap)
  
  - B-tree
    - ![B-tree](https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/B-tree.svg/600px-B-tree.svg.png)
    - 데이터베이스와, 파일 시스템에서 널리 사용되는 트리 자료구조
    - 모든 노드에 있는 값들은 정렬되어 있는 상태이며, 각노드마다 order를 나타내는 숫자인 m개의 자식을 가질 수 있다.
    - 이 B-tree를 B-tree of order m 이라고 한다.
    - B-tree는 노드의 접근시간이 노드에서의연산시간에 비해 훨씬 길 경우, 다른 구현 방식에 비해 상당한 이점을 가지고 있다(?)
</details>

<details>
  <summary>Graph</summary>
  
  ## Graph
  **Vertex와 Edge로 구성되어 있는 자료구조**
  1. 그래프 탐색 알고리즘
    - BFS
    - DFS
    
  2. MST(Minimum Spanning Tree) 알고리즘
    - 모든 Vertex를 연결하는 최소비용을 구하는 방법
    - prim 알고리즘
    - kruskal 알고리즘
    
  3. Shortest Path
    - 특정 노드에서 나머지노드의 최소길이를 구하는 방법
    - 다익스트라 알고리즘
</details>


